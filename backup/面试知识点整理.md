1. CAP一致性原则
一致性：强一致性/最终一致性，如2PC/3PC协议能保证一致性（通过保证事务的原子性）
强一致性要求任何时候所有节点看到的数据都是完全相同的；最终一致性相对比较宽松，它允许系统在短时间内存在数据不一致的情况，但保证经过一段时间后，所有节点的数据最终会达到一致的状态。
可用性是指系统在正常响应时间内返回合理的响应，即使部分节点出现故障，系统仍然可以继续提供服务。
分区容错性是指当网络分区故障发生时，系统仍然能够继续运行。
[CAP不可兼得](https://javabetter.cn/sidebar/sanfene/fenbushi.html#_2-%E4%B8%BA%E4%BB%80%E4%B9%88-cap-%E4%B8%8D%E5%8F%AF%E5%85%BC%E5%BE%97%E5%91%A2)：
分区容错性（P）必须要满足，否则分布式系统无意义（分布式系统希望单个节点或网络出现故障整个服务仍旧能正常运行）。
在AP之间做取舍。
2.从汇编代码的角度理解局部变量存储在程序的栈空间
rbp基址指针,rsp栈指针
函数被调用时：
保存调用者的基址指针在函数的栈空间：pushq %rbp
将基址指针更新为当前函数的位置，也就是当前的栈指针 movq %rsp, rbp
将传进来的函数参数作为局部变量保存在栈空间（参数可能存储在%edi,%esi）
movl	%edi, -4(%rbp)    # 将第一个参数a保存到栈帧
movl	%esi, -8(%rbp)    # 将第二个参数b保存到栈帧
函数运算时将栈空间内的局部变量加载到寄存器完成运算，结果存储在寄存器，可能赋给某个在栈空间的局部变量。
函数返回时，清理栈帧，将基址指针恢复为调用者的基址指针，将返回结果存储在寄存器如eax
popq	%rbp              # 恢复旧的基址指针
ret   
3.[消息队列](https://javabetter.cn/sidebar/sanfene/rocketmq.html#_4-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B)
解耦、异步、削峰
