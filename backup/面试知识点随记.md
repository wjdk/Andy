- CAP一致性原则

一致性：强一致性/最终一致性。
强一致性要求任何时候所有节点看到的数据都是完全相同的；最终一致性相对比较宽松，它允许系统在短时间内存在数据不一致的情况，但保证经过一段时间后，所有节点的数据最终会达到一致的状态。
实现一致性的例子：2PC/3PC协议（通过保证事务的原子性）。
可用性是指系统在正常响应时间内返回合理的响应，即使部分节点出现故障，系统仍然可以继续提供服务。
分区容错性是指当网络分区故障发生时，系统仍然能够继续运行。
[CAP不可兼得](https://javabetter.cn/sidebar/sanfene/fenbushi.html#_2-%E4%B8%BA%E4%BB%80%E4%B9%88-cap-%E4%B8%8D%E5%8F%AF%E5%85%BC%E5%BE%97%E5%91%A2)：
分区容错性（P）必须要满足，在CA之间做取舍。
- 从汇编代码的角度理解局部变量存储在程序的栈空间
rbp基址指针,rsp栈指针
函数被调用时：
保存调用者的基址指针在函数的栈空间：`pushq %rbp`
将基址指针更新为当前函数的位置，也就是当前的栈指针 `movq %rsp, rbp`
将传进来的函数参数作为局部变量保存在栈空间（参数可能存储在%edi,%esi）
`movl	%edi, -4(%rbp)    # 将第一个参数a保存到栈帧`
`movl	%esi, -8(%rbp)    # 将第二个参数b保存到栈帧`
函数运算时将栈空间内的局部变量加载到寄存器完成运算，结果存储在寄存器，可能赋给某个在栈空间的局部变量。
函数返回时，清理栈帧，将基址指针恢复为调用者的基址指针，将返回结果存储在寄存器如eax
`popq	%rbp              # 恢复旧的基址指针`
`ret   `
- [消息队列](https://www.woshinlper.com/system-design/data-communication/RocketMQ/)

解耦、异步、削峰
