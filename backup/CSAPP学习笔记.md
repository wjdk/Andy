### 计算机系统漫游

<img width="1336" height="823" alt="Image" src="https://github.com/user-attachments/assets/96202fd8-a857-41d3-a3bb-49eb343fd7d8" />

文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程是对处理器、主存和I/O设备的抽象表示；虚拟机是对整个计算机的抽象，包括操作系统、处理器和程序。

操作系统提供一种假象，程序看上去是独占地使用处理器、主存和I/O设设备。

内核是操作系统代码常驻主存的部分。

### 链接

#### 可重定位目标文件

ELF 头(ELF header)以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类（如 x86-64）、节头部表(section header table) 的文件偏移，以及节头部表中条目的大小和数最。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目(entry) 。

<img width="502" height="592" alt="Image" src="https://github.com/user-attachments/assets/07327c3d-f776-44bb-b4a1-c65e6dde49d7" />

.text：已编译程序的机器代码。

.rodata：只读数据，比如 printf 语句中的格式串和开关语句的跳转表。

.data：已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。

.bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。

.symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。

.rel.text：一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。

.rel.data：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。

.debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。

.line：原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。

.strtab：一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。

#### 静态链接概述

<img width="848" height="573" alt="Image" src="https://github.com/user-attachments/assets/6c8aff68-f8fb-4cdc-b38b-c3b6ddb026a2" />

#### 重定位

重定位由两步组成：
- 重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。
- 重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构。（绝对引用和相对引用两种）

#### 可执行目标文件

<img width="980" height="626" alt="Image" src="https://github.com/user-attachments/assets/010223a6-92ed-4dd6-bb73-94c7b8f886b5" />

#### 静态链接和动态链接

<img width="443" height="447" alt="Image" src="https://github.com/user-attachments/assets/e1ad2f1c-8577-4d7d-a869-a890ff4cc0de" />

**静态链接在程序被加载到内存之前完成，动态链接在程序被加载到内存之后完成——因此共享库必须使用动态链接！**
“假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。”——加载时重定位

#### 加载时重定位和PIC

动态链接共享库的两种方法：加载时重定位和位置无关码（PIC）

//待填坑（学昏过去了）

[加载时重定位](https://zhuanlan.zhihu.com/p/565554516)

[共享库中的地址无关码（PIC）](https://zhuanlan.zhihu.com/p/565729547)

#### 小结
链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处理称为目标文件的二进制文件，它有 3 种不同的形式：可重定位的、可执行的和共享的。可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到内存中并执行。共享目标文件（共享库）是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用 dlopen 库的函数时。

链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到亠个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。

静态链接器是由像 GCC 这样的编译驱动程序调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入微妙的错误。

多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用。许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起令人迷惑的链接时错误的来源。

加载器将可执行文件的内容映射到内存，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的例程和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。

被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。

#### 实验

[gcc命令](https://www.runoob.com/w3cnote/gcc-parameter-detail.html)

[反汇编命令](https://www.runoob.com/linux/linux-comm-objdump.html)

使用`gcc -c test.cpp`编译`test.cpp`得到可重定位目标文件`test.o`

使用`objdump -D test.o`反汇编可重定位目标文件，得到所有节区的反汇编代码。


## 参考资料

CSAPP书籍
[gitbook](https://hansimov.gitbook.io/csapp)